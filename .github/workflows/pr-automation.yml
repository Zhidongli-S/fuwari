name: PR Automation

on:
  pull_request_target:
    types: [opened, synchronize, reopened]
  issue_comment:
    types: [created]
  workflow_dispatch:

permissions:
  pull-requests: write
  contents: read
  issues: write

jobs:
  path-check:
    if: github.event_name != 'issue_comment'
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.gate.outputs.should_run }}
    steps:
      - name: Check PR file paths
        id: gate
        uses: actions/github-script@v7
        with:
          script: |
            console.log("=== PR Data Path Check Started ===");

            if (context.eventName === "workflow_dispatch") {
              console.log("workflow_dispatch: skip path-check (no single PR context)");
              core.setOutput("should_run", "true");
              return;
            }

            const allowedPaths = [
              /^src\/data\/friends\/.+\.json$/,
              /^src\/data\/sponsors\/.+\.json$/
            ];

            const prNumber = context.payload.pull_request.number;

            console.log("Checking PR:", prNumber);

            const files = await github.paginate(
              github.rest.pulls.listFiles,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
              }
            );

            if (!files.length) {
              console.log("No files changed.");
              core.setOutput("should_run", "false");
              return;
            }

            let validJsonChanged = false;
            let invalidPath = false;

            for (const file of files) {

              console.log("File:", file.filename);

              if (file.status === "removed") continue;

              if (file.filename.endsWith(".json")) {

                const allowed = allowedPaths.some(pattern =>
                  pattern.test(file.filename)
                );

                if (!allowed) {
                  invalidPath = true;
                  break;
                }

                validJsonChanged = true;
              }
            }

            if (invalidPath) {

              console.log("Invalid file path detected.");
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  name: "path-check-passed"
                });
              } catch (e) {}

              core.setOutput("should_run", "false");
              return;
            }

            if (!validJsonChanged) {

              console.log("No JSON files changed.");

              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  name: "path-check-passed"
                });
              } catch (e) {}

              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: ["invalid-json"]
              });

              core.setOutput("should_run", "false");
              return;
            }

            console.log("Path check passed.");

            try {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                name: "invalid-json"
              });
            } catch (e) {}

            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              labels: ["path-check-passed"]
            });

            core.setOutput("should_run", "true");
            console.log("=== PR Data Path Check Finished ===");

  json-check:
    if: github.event_name != 'issue_comment' && needs.path-check.outputs.should_run == 'true'
    needs: [path-check]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: JSON validation
        uses: actions/github-script@v7
        with:
          script: |
            const validLabel = "有效 JSON";
            const invalidLabel = "无效 JSON";
            const requiredLabels = ["友链", "赞助"];

            async function checkPR(prNumber) {

              const pr = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
              });

              const currentLabels = pr.data.labels.map(l => l.name);

              if (!currentLabels.some(l => requiredLabels.includes(l))) {
                console.log(`PR #${prNumber} skipped (no required tag)`);
                return;
              }

              console.log(`Checking PR #${prNumber}`);

              const files = await github.paginate(
                github.rest.pulls.listFiles,
                {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                }
              );

              let hasJsonFile = false;
              let allValid = true;

              for (const file of files) {
                if (file.status === "removed") continue;

                if (file.filename.endsWith(".json")) {
                  hasJsonFile = true;

                  try {
                    const content = await github.rest.repos.getContent({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      path: file.filename,
                      ref: pr.data.head.sha
                    });

                    const buff = Buffer.from(content.data.content, 'base64');
                    const text = buff.toString('utf8');

                    JSON.parse(text);
                    console.log(`${file.filename} ✅ valid`);
                  } catch (e) {
                    console.log(`${file.filename} ❌ invalid`);
                    allValid = false;
                  }
                }
              }

              if (!hasJsonFile) {
                console.log("No JSON files changed → mark as invalid");
                allValid = false;
              }

              for (const label of [validLabel, invalidLabel]) {
                if (currentLabels.includes(label)) {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    name: label,
                  });
                }
              }

              const labelToAdd = allValid ? validLabel : invalidLabel;

              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: [labelToAdd],
              });

              console.log(`Added label ${labelToAdd} to PR #${prNumber}`);
            }

            if (context.eventName === "workflow_dispatch") {

              const prs = await github.paginate(
                github.rest.pulls.list,
                {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: "open",
                }
              );

              for (const pr of prs) {
                await checkPR(pr.number);
              }

            } else {

              const prNumber = context.payload.pull_request.number;
              await checkPR(prNumber);
            }

  title-update:
    if: github.event_name != 'issue_comment' && needs.path-check.outputs.should_run == 'true'
    needs: [path-check, json-check]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Parse JSON and update title
        uses: actions/github-script@v7
        with:
          script: |
            const validLabel = "有效 JSON";
            const friendLabel = "友链";
            const sponsorLabel = "赞助";

            async function processPR(prNumber) {

              const pr = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
              });

              const labels = pr.data.labels.map(l => l.name);

              if (!labels.includes(validLabel)) {
                console.log(`PR #${prNumber} skipped (not valid JSON)`);
                return;
              }

              let typePrefix = null;

              if (labels.includes(friendLabel)) {
                typePrefix = "友链";
              } else if (labels.includes(sponsorLabel)) {
                typePrefix = "赞助";
              } else {
                console.log("No type label found.");
                return;
              }

              const files = await github.paginate(
                github.rest.pulls.listFiles,
                {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                }
              );

              let nameValue = null;

              for (const file of files) {
                if (file.status === "removed") continue;

                if (file.filename.endsWith(".json")) {

                  const content = await github.rest.repos.getContent({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    path: file.filename,
                    ref: pr.data.head.sha
                  });

                  const buff = Buffer.from(content.data.content, 'base64');
                  const text = buff.toString('utf8');
                  const json = JSON.parse(text);

                  if (json.name) {
                    nameValue = json.name;
                    break;
                  }
                }
              }

              if (!nameValue) {
                console.log("No name field found.");
                return;
              }

              const newTitle = `${typePrefix}：${nameValue}`;

              if (pr.data.title === newTitle) {
                console.log("Title already correct.");
                return;
              }

              await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                title: newTitle
              });

              console.log(`Updated PR title to: ${newTitle}`);
            }

            if (context.eventName === "workflow_dispatch") {

              const prs = await github.paginate(
                github.rest.pulls.list,
                {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: "open",
                }
              );

              for (const pr of prs) {
                await processPR(pr.number);
              }

            } else {

              const prNumber = context.payload.pull_request.number;
              await processPR(prNumber);
            }

  link-check:
    if: github.event_name != 'issue_comment' && needs.path-check.outputs.should_run == 'true'
    needs: [path-check, title-update]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check links
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");

            const validLabel = "有效 JSON";
            const ownershipLabel = "所有权验证未完成";

            async function getSiteUrl() {
              try {
                const configContent = fs.readFileSync("astro.config.mjs", "utf8");
                const match = configContent.match(/site:\s*["']([^"']+)["']/);
                if (match && match[1]) {
                  return match[1].replace(/\/$/, "");
                }
              } catch (err) {
                console.log("Failed to read astro.config.mjs");
              }
              return null;
            }

            async function checkUrl(targetUrl) {
              if (!targetUrl) return false;

              try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 10000);

                const res = await fetch(targetUrl, {
                  redirect: "follow",
                  signal: controller.signal
                });

                clearTimeout(timeout);

                return res.status === 200;
              } catch (e) {
                return false;
              }
            }

            async function processPR(prNumber) {

              const pr = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
              });

              const labels = pr.data.labels.map(l => l.name);

              if (!labels.includes(validLabel)) {
                console.log("Not valid JSON, skip.");
                return;
              }

              const files = await github.paginate(
                github.rest.pulls.listFiles,
                {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                }
              );

              let jsonData = null;

              for (const file of files) {
                if (file.filename.endsWith(".json") && file.status !== "removed") {
                  const content = await github.rest.repos.getContent({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    path: file.filename,
                    ref: pr.data.head.sha
                  });

                  const buff = Buffer.from(content.data.content, 'base64');
                  jsonData = JSON.parse(buff.toString("utf8"));
                  break;
                }
              }

              if (!jsonData) return;

              const siteUrl = await getSiteUrl();

              function resolveUrl(u) {
                if (!u) return null;

                if (u.startsWith("http://") || u.startsWith("https://")) {
                  return u;
                }

                if (u.startsWith("/") && siteUrl) {
                  return siteUrl + u;
                }

                return u;
              }

              const avatarUrl = resolveUrl(jsonData.avatar);
              const pageUrl = resolveUrl(jsonData.url);

              const avatarOk = await checkUrl(avatarUrl);
              const urlOk = await checkUrl(pageUrl);

              const newLabels = [
                avatarOk ? "avatar yes" : "avatar no",
                urlOk ? "url yes" : "url no"
              ];

              if (avatarOk && urlOk) {
                newLabels.push(ownershipLabel);
              }

              const statusLabels = [
                "avatar yes",
                "avatar no",
                "url yes",
                "url no",
                ownershipLabel
              ];

              for (const l of statusLabels) {
                if (labels.includes(l)) {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    name: l,
                  });
                }
              }

              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: newLabels,
              });

              console.log("Link check done.");
            }

            if (context.eventName === "workflow_dispatch") {

              const prs = await github.paginate(
                github.rest.pulls.list,
                {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: "open",
                }
              );

              for (const pr of prs) {
                await processPR(pr.number);
              }

            } else {

              const prNumber = context.payload.pull_request.number;
              await processPR(prNumber);
            }

  ownership-init:
    if: github.event_name != 'issue_comment' && needs.path-check.outputs.should_run == 'true'
    needs: [path-check, link-check]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Initialize ownership verification
        uses: actions/github-script@v7
        with:
          script: |
            console.log("=== Ownership Verification Init Started ===");

            const pendingLabel = "所有权验证未完成";
            const runningLabel = "所有权验证进行中";

            function randomString(len = 8) {
              return Math.random().toString(36).substring(2, 2 + len);
            }

            async function processPR(prNumber) {

              console.log("Checking PR:", prNumber);

              const pr = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
              });

              const labels = pr.data.labels.map(l => l.name);
              console.log("Labels:", labels);

              if (!labels.includes(pendingLabel)) {
                console.log("Skip PR (no pending label)");
                return;
              }

              const files = await github.paginate(
                github.rest.pulls.listFiles,
                {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                }
              );

              let jsonData = null;

              for (const file of files) {
                if (file.filename.endsWith(".json") && file.status !== "removed") {
                  console.log("Found JSON:", file.filename);

                  const content = await github.rest.repos.getContent({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    path: file.filename,
                    ref: pr.data.head.sha
                  });

                  const buff = Buffer.from(content.data.content, 'base64');
                  jsonData = JSON.parse(buff.toString("utf8"));
                  break;
                }
              }

              if (!jsonData || !jsonData.url) {
                console.log("No valid JSON or url field.");
                return;
              }

              const siteUrl = jsonData.url.replace(/\/$/, "");
              const random = randomString();
              const verifyPath = `${siteUrl}/${random}.txt`;
              const prHash = pr.data.head.sha;

              const commentBody = [
                "基础检查已完成，需要所有权验证。",
                "",
                "请在您的网站创建以下文件：",
                "",
                verifyPath,
                "",
                "文件内容应为：",
                "",
                prHash,
                "",
                "若已准备好，请回复该 PR 以完成最终的验证流程。"
              ].join("\n");

              console.log("Posting comment...");

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: commentBody,
              });

              console.log("Switching labels...");

              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  name: pendingLabel,
                });
              } catch (e) {
                console.log("Pending label not found.");
              }

              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: [runningLabel],
              });

              console.log("Ownership verification initialized for PR #" + prNumber);
            }

            const prs = await github.paginate(
              github.rest.pulls.list,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: "open",
              }
            );

            console.log("Total open PRs:", prs.length);

            for (const pr of prs) {
              await processPR(pr.number);
            }

            console.log("=== Ownership Verification Init Finished ===");

  ownership-verify:
    if: (github.event_name == 'workflow_dispatch' || (github.event_name == 'pull_request_target' && (github.event.action == 'synchronize' || github.event.action == 'reopened'))) && needs.path-check.outputs.should_run == 'true'
    needs: [path-check, ownership-init]
    runs-on: ubuntu-latest
    steps:
      - name: Final ownership verification
        uses: actions/github-script@v7
        with:
          script: |
            const runningLabel = "所有权验证进行中";

            console.log("=== Ownership Final Verification Started ===");

            async function verifyPR(prNumber) {

              console.log("Checking PR:", prNumber);

              const pr = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
              });

              const labels = pr.data.labels.map(l => l.name);

              if (!labels.includes(runningLabel)) {
                console.log("Skip PR (not in verification)");
                return;
              }

              const comments = await github.paginate(
                github.rest.issues.listComments,
                {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                }
              );

              let verifyUrl = null;

              for (const comment of comments.reverse()) {
                const match = comment.body.match(/https?:\/\/[^\s]+\.txt/);
                if (match) {
                  verifyUrl = match[0];
                  break;
                }
              }

              if (!verifyUrl) {
                console.log("No verification URL found.");
                return;
              }

              console.log("Verification URL:", verifyUrl);

              const prHash = pr.data.head.sha;

              try {

                const response = await fetch(verifyUrl, {
                  redirect: "follow"
                });

                const text = await response.text();

                if (!response.ok) {
                  throw new Error("HTTP Status: " + response.status);
                }

                if (text.trim() !== prHash.trim()) {
                  throw new Error(
                    "File content mismatch. Expected: " +
                    prHash +
                    " Got: " +
                    text.trim()
                  );
                }

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: "所有权验证已成功，PR 将自动合并！"
                });

                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  name: runningLabel,
                });

                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  merge_method: "squash"
                });

                console.log("PR merged:", prNumber);

              } catch (error) {

                const log = error.message;

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: "所有权验证未成功，详细日志：" + log
                });

                console.log("Verification failed:", log);
              }
            }

            if (context.eventName === "workflow_dispatch") {

              const prs = await github.paginate(
                github.rest.pulls.list,
                {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: "open",
                }
              );

              for (const pr of prs) {
                await verifyPR(pr.number);
              }

            } else {

              const prNumber = context.payload.pull_request.number;
              await verifyPR(prNumber);
            }

            console.log("=== Ownership Final Verification Finished ===");

  ownership-verify-comment:
    if: github.event_name == 'issue_comment'
    runs-on: ubuntu-latest
    steps:
      - name: Final ownership verification (comment)
        uses: actions/github-script@v7
        with:
          script: |
            const runningLabel = "所有权验证进行中";

            console.log("=== Ownership Final Verification Started ===");

            if (!context.payload.issue.pull_request) {
              console.log("Not a PR comment.");
              return;
            }

            async function verifyPR(prNumber) {

              console.log("Checking PR:", prNumber);

              const pr = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
              });

              const labels = pr.data.labels.map(l => l.name);

              if (!labels.includes(runningLabel)) {
                console.log("Skip PR (not in verification)");
                return;
              }

              const comments = await github.paginate(
                github.rest.issues.listComments,
                {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                }
              );

              let verifyUrl = null;

              for (const comment of comments.reverse()) {
                const match = comment.body.match(/https?:\/\/[^\s]+\.txt/);
                if (match) {
                  verifyUrl = match[0];
                  break;
                }
              }

              if (!verifyUrl) {
                console.log("No verification URL found.");
                return;
              }

              console.log("Verification URL:", verifyUrl);

              const prHash = pr.data.head.sha;

              try {

                const response = await fetch(verifyUrl, {
                  redirect: "follow"
                });

                const text = await response.text();

                if (!response.ok) {
                  throw new Error("HTTP Status: " + response.status);
                }

                if (text.trim() !== prHash.trim()) {
                  throw new Error(
                    "File content mismatch. Expected: " +
                    prHash +
                    " Got: " +
                    text.trim()
                  );
                }

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: "所有权验证已成功，PR 将自动合并！"
                });

                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  name: runningLabel,
                });

                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  merge_method: "squash"
                });

                console.log("PR merged:", prNumber);

              } catch (error) {

                const log = error.message;

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: "所有权验证未成功，详细日志：" + log
                });

                console.log("Verification failed:", log);
              }
            }

            const prNumber = context.payload.issue.number;
            await verifyPR(prNumber);

            console.log("=== Ownership Final Verification Finished ===");
